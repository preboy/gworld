// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: 2_player.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PlayerDataRequest struct {
	Id uint64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *PlayerDataRequest) Reset()                    { *m = PlayerDataRequest{} }
func (m *PlayerDataRequest) String() string            { return proto.CompactTextString(m) }
func (*PlayerDataRequest) ProtoMessage()               {}
func (*PlayerDataRequest) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{0} }

func (m *PlayerDataRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type PlayerDataResponse struct {
	Acct  string  `protobuf:"bytes,1,opt,name=Acct,proto3" json:"Acct,omitempty"`
	Name  string  `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Pid   string  `protobuf:"bytes,3,opt,name=Pid,proto3" json:"Pid,omitempty"`
	Sid   uint32  `protobuf:"varint,4,opt,name=Sid,proto3" json:"Sid,omitempty"`
	Exp   uint64  `protobuf:"varint,5,opt,name=Exp,proto3" json:"Exp,omitempty"`
	Lv    uint32  `protobuf:"varint,6,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Vip   uint32  `protobuf:"varint,7,opt,name=Vip,proto3" json:"Vip,omitempty"`
	Male  bool    `protobuf:"varint,8,opt,name=Male,proto3" json:"Male,omitempty"`
	Items []*Item `protobuf:"bytes,9,rep,name=Items" json:"Items,omitempty"`
	Heros []*Hero `protobuf:"bytes,10,rep,name=Heros" json:"Heros,omitempty"`
	Auras []*Aura `protobuf:"bytes,11,rep,name=Auras" json:"Auras,omitempty"`
}

func (m *PlayerDataResponse) Reset()                    { *m = PlayerDataResponse{} }
func (m *PlayerDataResponse) String() string            { return proto.CompactTextString(m) }
func (*PlayerDataResponse) ProtoMessage()               {}
func (*PlayerDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{1} }

func (m *PlayerDataResponse) GetAcct() string {
	if m != nil {
		return m.Acct
	}
	return ""
}

func (m *PlayerDataResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerDataResponse) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *PlayerDataResponse) GetSid() uint32 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *PlayerDataResponse) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *PlayerDataResponse) GetLv() uint32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *PlayerDataResponse) GetVip() uint32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *PlayerDataResponse) GetMale() bool {
	if m != nil {
		return m.Male
	}
	return false
}

func (m *PlayerDataResponse) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *PlayerDataResponse) GetHeros() []*Hero {
	if m != nil {
		return m.Heros
	}
	return nil
}

func (m *PlayerDataResponse) GetAuras() []*Aura {
	if m != nil {
		return m.Auras
	}
	return nil
}

type GMCommandRequest struct {
	Command string `protobuf:"bytes,1,opt,name=Command,proto3" json:"Command,omitempty"`
}

func (m *GMCommandRequest) Reset()                    { *m = GMCommandRequest{} }
func (m *GMCommandRequest) String() string            { return proto.CompactTextString(m) }
func (*GMCommandRequest) ProtoMessage()               {}
func (*GMCommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{2} }

func (m *GMCommandRequest) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

type GMCommandResponse struct {
	Result int32 `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
}

func (m *GMCommandResponse) Reset()                    { *m = GMCommandResponse{} }
func (m *GMCommandResponse) String() string            { return proto.CompactTextString(m) }
func (*GMCommandResponse) ProtoMessage()               {}
func (*GMCommandResponse) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{3} }

func (m *GMCommandResponse) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

// 使用道具
type UseItemRequest struct {
	Id   uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Cnt  uint32 `protobuf:"varint,2,opt,name=Cnt,proto3" json:"Cnt,omitempty"`
	Arg1 int32  `protobuf:"varint,3,opt,name=Arg1,proto3" json:"Arg1,omitempty"`
	Arg2 int32  `protobuf:"varint,4,opt,name=Arg2,proto3" json:"Arg2,omitempty"`
}

func (m *UseItemRequest) Reset()                    { *m = UseItemRequest{} }
func (m *UseItemRequest) String() string            { return proto.CompactTextString(m) }
func (*UseItemRequest) ProtoMessage()               {}
func (*UseItemRequest) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{4} }

func (m *UseItemRequest) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UseItemRequest) GetCnt() uint32 {
	if m != nil {
		return m.Cnt
	}
	return 0
}

func (m *UseItemRequest) GetArg1() int32 {
	if m != nil {
		return m.Arg1
	}
	return 0
}

func (m *UseItemRequest) GetArg2() int32 {
	if m != nil {
		return m.Arg2
	}
	return 0
}

type UseItemResponse struct {
	Result uint32 `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
}

func (m *UseItemResponse) Reset()                    { *m = UseItemResponse{} }
func (m *UseItemResponse) String() string            { return proto.CompactTextString(m) }
func (*UseItemResponse) ProtoMessage()               {}
func (*UseItemResponse) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{5} }

func (m *UseItemResponse) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type MarketBuyRequest struct {
	Index uint32 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *MarketBuyRequest) Reset()                    { *m = MarketBuyRequest{} }
func (m *MarketBuyRequest) String() string            { return proto.CompactTextString(m) }
func (*MarketBuyRequest) ProtoMessage()               {}
func (*MarketBuyRequest) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{6} }

func (m *MarketBuyRequest) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MarketBuyRequest) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type MarketBuyResponse struct {
	ErrorCode uint32 `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *MarketBuyResponse) Reset()                    { *m = MarketBuyResponse{} }
func (m *MarketBuyResponse) String() string            { return proto.CompactTextString(m) }
func (*MarketBuyResponse) ProtoMessage()               {}
func (*MarketBuyResponse) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{7} }

func (m *MarketBuyResponse) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ItemUpdate struct {
	Items []*Item `protobuf:"bytes,1,rep,name=Items" json:"Items,omitempty"`
}

func (m *ItemUpdate) Reset()                    { *m = ItemUpdate{} }
func (m *ItemUpdate) String() string            { return proto.CompactTextString(m) }
func (*ItemUpdate) ProtoMessage()               {}
func (*ItemUpdate) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{8} }

func (m *ItemUpdate) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type PlayerExpUpdate struct {
	Lv  uint32 `protobuf:"varint,1,opt,name=Lv,proto3" json:"Lv,omitempty"`
	Exp uint64 `protobuf:"varint,2,opt,name=Exp,proto3" json:"Exp,omitempty"`
}

func (m *PlayerExpUpdate) Reset()                    { *m = PlayerExpUpdate{} }
func (m *PlayerExpUpdate) String() string            { return proto.CompactTextString(m) }
func (*PlayerExpUpdate) ProtoMessage()               {}
func (*PlayerExpUpdate) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{9} }

func (m *PlayerExpUpdate) GetLv() uint32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *PlayerExpUpdate) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type NoticeUpdate struct {
	Flag   int32  `protobuf:"varint,1,opt,name=Flag,proto3" json:"Flag,omitempty"`
	Notice string `protobuf:"bytes,2,opt,name=Notice,proto3" json:"Notice,omitempty"`
}

func (m *NoticeUpdate) Reset()                    { *m = NoticeUpdate{} }
func (m *NoticeUpdate) String() string            { return proto.CompactTextString(m) }
func (*NoticeUpdate) ProtoMessage()               {}
func (*NoticeUpdate) Descriptor() ([]byte, []int) { return fileDescriptor2Player, []int{10} }

func (m *NoticeUpdate) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *NoticeUpdate) GetNotice() string {
	if m != nil {
		return m.Notice
	}
	return ""
}

func init() {
	proto.RegisterType((*PlayerDataRequest)(nil), "msg.PlayerDataRequest")
	proto.RegisterType((*PlayerDataResponse)(nil), "msg.PlayerDataResponse")
	proto.RegisterType((*GMCommandRequest)(nil), "msg.GMCommandRequest")
	proto.RegisterType((*GMCommandResponse)(nil), "msg.GMCommandResponse")
	proto.RegisterType((*UseItemRequest)(nil), "msg.UseItemRequest")
	proto.RegisterType((*UseItemResponse)(nil), "msg.UseItemResponse")
	proto.RegisterType((*MarketBuyRequest)(nil), "msg.MarketBuyRequest")
	proto.RegisterType((*MarketBuyResponse)(nil), "msg.MarketBuyResponse")
	proto.RegisterType((*ItemUpdate)(nil), "msg.ItemUpdate")
	proto.RegisterType((*PlayerExpUpdate)(nil), "msg.PlayerExpUpdate")
	proto.RegisterType((*NoticeUpdate)(nil), "msg.NoticeUpdate")
}
func (m *PlayerDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *PlayerDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Acct) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarint2Player(dAtA, i, uint64(len(m.Acct)))
		i += copy(dAtA[i:], m.Acct)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarint2Player(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Pid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarint2Player(dAtA, i, uint64(len(m.Pid)))
		i += copy(dAtA[i:], m.Pid)
	}
	if m.Sid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Sid))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Exp))
	}
	if m.Lv != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Lv))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Vip))
	}
	if m.Male {
		dAtA[i] = 0x40
		i++
		if m.Male {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x4a
			i++
			i = encodeVarint2Player(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Heros) > 0 {
		for _, msg := range m.Heros {
			dAtA[i] = 0x52
			i++
			i = encodeVarint2Player(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Auras) > 0 {
		for _, msg := range m.Auras {
			dAtA[i] = 0x5a
			i++
			i = encodeVarint2Player(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GMCommandRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GMCommandRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarint2Player(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	return i, nil
}

func (m *GMCommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GMCommandResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *UseItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseItemRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Id))
	}
	if m.Cnt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Cnt))
	}
	if m.Arg1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Arg1))
	}
	if m.Arg2 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Arg2))
	}
	return i, nil
}

func (m *UseItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseItemResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MarketBuyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketBuyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Index))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *MarketBuyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketBuyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ItemUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarint2Player(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PlayerExpUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerExpUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Lv))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *NoticeUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoticeUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint2Player(dAtA, i, uint64(m.Flag))
	}
	if len(m.Notice) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarint2Player(dAtA, i, uint64(len(m.Notice)))
		i += copy(dAtA[i:], m.Notice)
	}
	return i, nil
}

func encodeVarint2Player(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PlayerDataRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov2Player(uint64(m.Id))
	}
	return n
}

func (m *PlayerDataResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Acct)
	if l > 0 {
		n += 1 + l + sov2Player(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sov2Player(uint64(l))
	}
	l = len(m.Pid)
	if l > 0 {
		n += 1 + l + sov2Player(uint64(l))
	}
	if m.Sid != 0 {
		n += 1 + sov2Player(uint64(m.Sid))
	}
	if m.Exp != 0 {
		n += 1 + sov2Player(uint64(m.Exp))
	}
	if m.Lv != 0 {
		n += 1 + sov2Player(uint64(m.Lv))
	}
	if m.Vip != 0 {
		n += 1 + sov2Player(uint64(m.Vip))
	}
	if m.Male {
		n += 2
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sov2Player(uint64(l))
		}
	}
	if len(m.Heros) > 0 {
		for _, e := range m.Heros {
			l = e.Size()
			n += 1 + l + sov2Player(uint64(l))
		}
	}
	if len(m.Auras) > 0 {
		for _, e := range m.Auras {
			l = e.Size()
			n += 1 + l + sov2Player(uint64(l))
		}
	}
	return n
}

func (m *GMCommandRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sov2Player(uint64(l))
	}
	return n
}

func (m *GMCommandResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sov2Player(uint64(m.Result))
	}
	return n
}

func (m *UseItemRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov2Player(uint64(m.Id))
	}
	if m.Cnt != 0 {
		n += 1 + sov2Player(uint64(m.Cnt))
	}
	if m.Arg1 != 0 {
		n += 1 + sov2Player(uint64(m.Arg1))
	}
	if m.Arg2 != 0 {
		n += 1 + sov2Player(uint64(m.Arg2))
	}
	return n
}

func (m *UseItemResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sov2Player(uint64(m.Result))
	}
	return n
}

func (m *MarketBuyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sov2Player(uint64(m.Index))
	}
	if m.Count != 0 {
		n += 1 + sov2Player(uint64(m.Count))
	}
	return n
}

func (m *MarketBuyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sov2Player(uint64(m.ErrorCode))
	}
	return n
}

func (m *ItemUpdate) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sov2Player(uint64(l))
		}
	}
	return n
}

func (m *PlayerExpUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sov2Player(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sov2Player(uint64(m.Exp))
	}
	return n
}

func (m *NoticeUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sov2Player(uint64(m.Flag))
	}
	l = len(m.Notice)
	if l > 0 {
		n += 1 + l + sov2Player(uint64(l))
	}
	return n
}

func sov2Player(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func soz2Player(x uint64) (n int) {
	return sov2Player(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlayerDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Male", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Male = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heros", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heros = append(m.Heros, &Hero{})
			if err := m.Heros[len(m.Heros)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auras", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auras = append(m.Auras, &Aura{})
			if err := m.Auras[len(m.Auras)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GMCommandRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GMCommandRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GMCommandRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GMCommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GMCommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GMCommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cnt", wireType)
			}
			m.Cnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg1", wireType)
			}
			m.Arg1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Arg1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg2", wireType)
			}
			m.Arg2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Arg2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketBuyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketBuyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketBuyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketBuyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketBuyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketBuyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerExpUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerExpUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerExpUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoticeUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoticeUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoticeUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength2Player
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip2Player(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength2Player
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skip2Player(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow2Player
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow2Player
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLength2Player
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflow2Player
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skip2Player(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLength2Player = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow2Player   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("2_player.proto", fileDescriptor2Player) }

var fileDescriptor2Player = []byte{
	// 489 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x86, 0xb1, 0x63, 0xa7, 0xcd, 0xb4, 0x49, 0x13, 0x0b, 0xa1, 0x15, 0x42, 0x21, 0x5a, 0x2e,
	0x41, 0x40, 0x44, 0xd3, 0x1b, 0x07, 0xa4, 0x36, 0x04, 0x88, 0xd4, 0x54, 0xd5, 0xa2, 0xf6, 0xc0,
	0x05, 0x2d, 0xf1, 0x2a, 0xb2, 0x88, 0xe3, 0x65, 0x77, 0x5d, 0x25, 0xcf, 0xc0, 0x85, 0xc7, 0xe2,
	0xc8, 0x23, 0xa0, 0xf0, 0x22, 0x68, 0x76, 0x37, 0xc1, 0x52, 0x73, 0xfb, 0xe7, 0xd3, 0x3f, 0xde,
	0xd1, 0x3f, 0x63, 0x68, 0x0d, 0xbf, 0xc8, 0x05, 0x5f, 0x0b, 0x35, 0x90, 0xaa, 0x30, 0x45, 0x52,
	0xcb, 0xf5, 0xfc, 0xf1, 0xf1, 0xeb, 0x81, 0x59, 0x4b, 0xe1, 0x10, 0x7d, 0x06, 0x9d, 0x6b, 0x6b,
	0x79, 0xc7, 0x0d, 0x67, 0xe2, 0x7b, 0x29, 0xb4, 0x49, 0x5a, 0x10, 0x4e, 0x52, 0x12, 0xf4, 0x82,
	0x7e, 0xc4, 0xc2, 0x49, 0x4a, 0x7f, 0x84, 0x90, 0x54, 0x5d, 0x5a, 0x16, 0x4b, 0x2d, 0x92, 0x04,
	0xa2, 0xf3, 0xd9, 0xcc, 0x58, 0x63, 0x83, 0x59, 0x8d, 0xec, 0x8a, 0xe7, 0x82, 0x84, 0x8e, 0xa1,
	0x4e, 0xda, 0x50, 0xbb, 0xce, 0x52, 0x52, 0xb3, 0x08, 0x25, 0x92, 0x4f, 0x59, 0x4a, 0xa2, 0x5e,
	0xd0, 0x6f, 0x32, 0x94, 0x48, 0xc6, 0x2b, 0x49, 0x62, 0xfb, 0x26, 0x4a, 0x1c, 0xe2, 0xf2, 0x8e,
	0xd4, 0xad, 0x25, 0xbc, 0xbc, 0x43, 0xc7, 0x6d, 0x26, 0xc9, 0x81, 0xeb, 0xb9, 0xcd, 0x24, 0xbe,
	0x35, 0xe5, 0x0b, 0x41, 0x0e, 0x7b, 0x41, 0xff, 0x90, 0x59, 0x9d, 0x3c, 0x85, 0x78, 0x62, 0x44,
	0xae, 0x49, 0xa3, 0x57, 0xeb, 0x1f, 0x0d, 0x1b, 0x83, 0x5c, 0xcf, 0x07, 0x48, 0x98, 0xe3, 0x68,
	0xf8, 0x28, 0x54, 0xa1, 0x09, 0x54, 0x0c, 0x48, 0x98, 0xe3, 0x68, 0x38, 0x2f, 0x15, 0xd7, 0xe4,
	0xa8, 0x62, 0x40, 0xc2, 0x1c, 0xa7, 0x2f, 0xa1, 0xfd, 0x61, 0x3a, 0x2a, 0xf2, 0x9c, 0x2f, 0xd3,
	0x6d, 0x62, 0x04, 0x0e, 0x3c, 0xf1, 0x69, 0x6c, 0x4b, 0xfa, 0x02, 0x3a, 0x15, 0xb7, 0x4f, 0xee,
	0x11, 0xd4, 0x99, 0xd0, 0xe5, 0xc2, 0x65, 0x17, 0x33, 0x5f, 0xd1, 0xcf, 0xd0, 0xba, 0xd1, 0xc2,
	0x8e, 0x7b, 0x6f, 0x15, 0x4d, 0x5c, 0x05, 0xa6, 0x30, 0x5a, 0x1a, 0x1b, 0x6f, 0x93, 0xa1, 0xb4,
	0x5b, 0x50, 0xf3, 0x53, 0x1b, 0x6f, 0xcc, 0xac, 0xf6, 0x6c, 0x68, 0x03, 0x76, 0x6c, 0x48, 0x9f,
	0xc3, 0xc9, 0xee, 0xdb, 0x7b, 0xc7, 0x68, 0xee, 0xc6, 0x78, 0x0b, 0xed, 0x29, 0x57, 0xdf, 0x84,
	0xb9, 0x28, 0xd7, 0xdb, 0x41, 0x1e, 0x42, 0x3c, 0x59, 0xa6, 0x62, 0xe5, 0xad, 0xae, 0x40, 0x3a,
	0x2a, 0x4a, 0x3f, 0x50, 0xc4, 0x5c, 0x41, 0x4f, 0xa1, 0x53, 0xe9, 0xf7, 0x8f, 0x3d, 0x81, 0xc6,
	0x58, 0xa9, 0x42, 0x8d, 0x8a, 0x54, 0xf8, 0x8f, 0xfc, 0x07, 0xf4, 0x15, 0x00, 0x8e, 0x76, 0x23,
	0x53, 0x6e, 0x2a, 0x5b, 0x0c, 0xf6, 0x6f, 0x91, 0x9e, 0xc1, 0x89, 0x3b, 0xc8, 0xf1, 0x4a, 0xfa,
	0x1e, 0x77, 0x2f, 0x41, 0xf5, 0x5e, 0xf0, 0xa2, 0xc2, 0xdd, 0x45, 0xd1, 0x37, 0x70, 0x7c, 0x55,
	0x98, 0x6c, 0x26, 0x7c, 0x47, 0x02, 0xd1, 0xfb, 0x05, 0x9f, 0xfb, 0x1d, 0x58, 0x8d, 0x91, 0x38,
	0x8f, 0xbf, 0x60, 0x5f, 0x5d, 0xb4, 0x7f, 0x6d, 0xba, 0xc1, 0xef, 0x4d, 0x37, 0xf8, 0xb3, 0xe9,
	0x06, 0x3f, 0xff, 0x76, 0x1f, 0x7c, 0xad, 0xdb, 0x1f, 0xe8, 0xec, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x66, 0x02, 0x20, 0xb6, 0x65, 0x03, 0x00, 0x00,
}
