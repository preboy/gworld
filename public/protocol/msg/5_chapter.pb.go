// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: 5_chapter.proto

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ChapterInfo struct {
	LootTs   int64    `protobuf:"varint,1,opt,name=LootTs,proto3" json:"LootTs,omitempty"`
	BreakId  uint32   `protobuf:"varint,2,opt,name=BreakId,proto3" json:"BreakId,omitempty"`
	Chapters []uint32 `protobuf:"varint,3,rep,packed,name=Chapters" json:"Chapters,omitempty"`
}

func (m *ChapterInfo) Reset()                    { *m = ChapterInfo{} }
func (m *ChapterInfo) String() string            { return proto.CompactTextString(m) }
func (*ChapterInfo) ProtoMessage()               {}
func (*ChapterInfo) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{0} }

func (m *ChapterInfo) GetLootTs() int64 {
	if m != nil {
		return m.LootTs
	}
	return 0
}

func (m *ChapterInfo) GetBreakId() uint32 {
	if m != nil {
		return m.BreakId
	}
	return 0
}

func (m *ChapterInfo) GetChapters() []uint32 {
	if m != nil {
		return m.Chapters
	}
	return nil
}

// 拉取关卡信息
type ChapterInfoRequest struct {
}

func (m *ChapterInfoRequest) Reset()                    { *m = ChapterInfoRequest{} }
func (m *ChapterInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*ChapterInfoRequest) ProtoMessage()               {}
func (*ChapterInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{1} }

type ChapterInfoResponse struct {
	ErrorCode uint32       `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Info      *ChapterInfo `protobuf:"bytes,2,opt,name=Info" json:"Info,omitempty"`
}

func (m *ChapterInfoResponse) Reset()                    { *m = ChapterInfoResponse{} }
func (m *ChapterInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*ChapterInfoResponse) ProtoMessage()               {}
func (*ChapterInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{2} }

func (m *ChapterInfoResponse) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ChapterInfoResponse) GetInfo() *ChapterInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// 关卡战斗
type ChapterFightingRequest struct {
	Team []uint32 `protobuf:"varint,1,rep,packed,name=Team" json:"Team,omitempty"`
}

func (m *ChapterFightingRequest) Reset()                    { *m = ChapterFightingRequest{} }
func (m *ChapterFightingRequest) String() string            { return proto.CompactTextString(m) }
func (*ChapterFightingRequest) ProtoMessage()               {}
func (*ChapterFightingRequest) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{3} }

func (m *ChapterFightingRequest) GetTeam() []uint32 {
	if m != nil {
		return m.Team
	}
	return nil
}

type ChapterFightingResponse struct {
	ErrorCode uint32        `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Win       bool          `protobuf:"varint,2,opt,name=Win,proto3" json:"Win,omitempty"`
	Rewards   []*Item       `protobuf:"bytes,3,rep,name=Rewards" json:"Rewards,omitempty"`
	Info      *ChapterInfo  `protobuf:"bytes,4,opt,name=Info" json:"Info,omitempty"`
	Br        *BattleResult `protobuf:"bytes,5,opt,name=Br" json:"Br,omitempty"`
}

func (m *ChapterFightingResponse) Reset()                    { *m = ChapterFightingResponse{} }
func (m *ChapterFightingResponse) String() string            { return proto.CompactTextString(m) }
func (*ChapterFightingResponse) ProtoMessage()               {}
func (*ChapterFightingResponse) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{4} }

func (m *ChapterFightingResponse) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ChapterFightingResponse) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

func (m *ChapterFightingResponse) GetRewards() []*Item {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *ChapterFightingResponse) GetInfo() *ChapterInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ChapterFightingResponse) GetBr() *BattleResult {
	if m != nil {
		return m.Br
	}
	return nil
}

// 领取章节奖励
type ChapterRewardsRequest struct {
	Id uint32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *ChapterRewardsRequest) Reset()                    { *m = ChapterRewardsRequest{} }
func (m *ChapterRewardsRequest) String() string            { return proto.CompactTextString(m) }
func (*ChapterRewardsRequest) ProtoMessage()               {}
func (*ChapterRewardsRequest) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{5} }

func (m *ChapterRewardsRequest) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type ChapterRewardsResponse struct {
	ErrorCode uint32       `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Id        uint32       `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Rewards   []*Item      `protobuf:"bytes,3,rep,name=Rewards" json:"Rewards,omitempty"`
	Info      *ChapterInfo `protobuf:"bytes,4,opt,name=Info" json:"Info,omitempty"`
}

func (m *ChapterRewardsResponse) Reset()                    { *m = ChapterRewardsResponse{} }
func (m *ChapterRewardsResponse) String() string            { return proto.CompactTextString(m) }
func (*ChapterRewardsResponse) ProtoMessage()               {}
func (*ChapterRewardsResponse) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{6} }

func (m *ChapterRewardsResponse) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ChapterRewardsResponse) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChapterRewardsResponse) GetRewards() []*Item {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *ChapterRewardsResponse) GetInfo() *ChapterInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// 领取挂机奖励
type ChapterLootRequest struct {
}

func (m *ChapterLootRequest) Reset()                    { *m = ChapterLootRequest{} }
func (m *ChapterLootRequest) String() string            { return proto.CompactTextString(m) }
func (*ChapterLootRequest) ProtoMessage()               {}
func (*ChapterLootRequest) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{7} }

type ChapterLootResponse struct {
	ErrorCode uint32  `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
	Rewards   []*Item `protobuf:"bytes,2,rep,name=Rewards" json:"Rewards,omitempty"`
}

func (m *ChapterLootResponse) Reset()                    { *m = ChapterLootResponse{} }
func (m *ChapterLootResponse) String() string            { return proto.CompactTextString(m) }
func (*ChapterLootResponse) ProtoMessage()               {}
func (*ChapterLootResponse) Descriptor() ([]byte, []int) { return fileDescriptor5Chapter, []int{8} }

func (m *ChapterLootResponse) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ChapterLootResponse) GetRewards() []*Item {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func init() {
	proto.RegisterType((*ChapterInfo)(nil), "msg.ChapterInfo")
	proto.RegisterType((*ChapterInfoRequest)(nil), "msg.ChapterInfoRequest")
	proto.RegisterType((*ChapterInfoResponse)(nil), "msg.ChapterInfoResponse")
	proto.RegisterType((*ChapterFightingRequest)(nil), "msg.ChapterFightingRequest")
	proto.RegisterType((*ChapterFightingResponse)(nil), "msg.ChapterFightingResponse")
	proto.RegisterType((*ChapterRewardsRequest)(nil), "msg.ChapterRewardsRequest")
	proto.RegisterType((*ChapterRewardsResponse)(nil), "msg.ChapterRewardsResponse")
	proto.RegisterType((*ChapterLootRequest)(nil), "msg.ChapterLootRequest")
	proto.RegisterType((*ChapterLootResponse)(nil), "msg.ChapterLootResponse")
}
func (m *ChapterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LootTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.LootTs))
	}
	if m.BreakId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.BreakId))
	}
	if len(m.Chapters) > 0 {
		dAtA2 := make([]byte, len(m.Chapters)*10)
		var j1 int
		for _, num := range m.Chapters {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *ChapterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ChapterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.Info.Size()))
		n3, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ChapterFightingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterFightingRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Team) > 0 {
		dAtA5 := make([]byte, len(m.Team)*10)
		var j4 int
		for _, num := range m.Team {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *ChapterFightingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterFightingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Win {
		dAtA[i] = 0x10
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Rewards) > 0 {
		for _, msg := range m.Rewards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarint5Chapter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.Info.Size()))
		n6, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Br != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.Br.Size()))
		n7, err := m.Br.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ChapterRewardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterRewardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *ChapterRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.Id))
	}
	if len(m.Rewards) > 0 {
		for _, msg := range m.Rewards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarint5Chapter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.Info.Size()))
		n8, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ChapterLootRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterLootRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ChapterLootResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterLootResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarint5Chapter(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Rewards) > 0 {
		for _, msg := range m.Rewards {
			dAtA[i] = 0x12
			i++
			i = encodeVarint5Chapter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarint5Chapter(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ChapterInfo) Size() (n int) {
	var l int
	_ = l
	if m.LootTs != 0 {
		n += 1 + sov5Chapter(uint64(m.LootTs))
	}
	if m.BreakId != 0 {
		n += 1 + sov5Chapter(uint64(m.BreakId))
	}
	if len(m.Chapters) > 0 {
		l = 0
		for _, e := range m.Chapters {
			l += sov5Chapter(uint64(e))
		}
		n += 1 + sov5Chapter(uint64(l)) + l
	}
	return n
}

func (m *ChapterInfoRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ChapterInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sov5Chapter(uint64(m.ErrorCode))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sov5Chapter(uint64(l))
	}
	return n
}

func (m *ChapterFightingRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Team) > 0 {
		l = 0
		for _, e := range m.Team {
			l += sov5Chapter(uint64(e))
		}
		n += 1 + sov5Chapter(uint64(l)) + l
	}
	return n
}

func (m *ChapterFightingResponse) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sov5Chapter(uint64(m.ErrorCode))
	}
	if m.Win {
		n += 2
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sov5Chapter(uint64(l))
		}
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sov5Chapter(uint64(l))
	}
	if m.Br != nil {
		l = m.Br.Size()
		n += 1 + l + sov5Chapter(uint64(l))
	}
	return n
}

func (m *ChapterRewardsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sov5Chapter(uint64(m.Id))
	}
	return n
}

func (m *ChapterRewardsResponse) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sov5Chapter(uint64(m.ErrorCode))
	}
	if m.Id != 0 {
		n += 1 + sov5Chapter(uint64(m.Id))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sov5Chapter(uint64(l))
		}
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sov5Chapter(uint64(l))
	}
	return n
}

func (m *ChapterLootRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ChapterLootResponse) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sov5Chapter(uint64(m.ErrorCode))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sov5Chapter(uint64(l))
		}
	}
	return n
}

func sov5Chapter(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func soz5Chapter(x uint64) (n int) {
	return sov5Chapter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChapterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LootTs", wireType)
			}
			m.LootTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LootTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BreakId", wireType)
			}
			m.BreakId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BreakId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow5Chapter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Chapters = append(m.Chapters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow5Chapter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength5Chapter
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow5Chapter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Chapters = append(m.Chapters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Chapters", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ChapterInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterFightingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterFightingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterFightingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow5Chapter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Team = append(m.Team, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow5Chapter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength5Chapter
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow5Chapter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Team = append(m.Team, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterFightingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterFightingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterFightingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &Item{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ChapterInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Br", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Br == nil {
				m.Br = &BattleResult{}
			}
			if err := m.Br.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterRewardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterRewardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterRewardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &Item{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ChapterInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterLootRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterLootRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterLootRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterLootResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChapterLootResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChapterLootResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength5Chapter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &Item{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip5Chapter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLength5Chapter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skip5Chapter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow5Chapter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow5Chapter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLength5Chapter
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflow5Chapter
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skip5Chapter(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLength5Chapter = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow5Chapter   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("5_chapter.proto", fileDescriptor5Chapter) }

var fileDescriptor5Chapter = []byte{
	// 373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x52, 0xdd, 0x4a, 0xc3, 0x30,
	0x18, 0x35, 0xed, 0xdc, 0xcf, 0x37, 0xa7, 0x33, 0xea, 0x2c, 0x43, 0xca, 0xac, 0x82, 0xbb, 0x90,
	0x22, 0x13, 0x5f, 0xa0, 0x43, 0xa1, 0xe0, 0x55, 0x18, 0xa8, 0x78, 0x21, 0xd5, 0xc6, 0x6e, 0xb8,
	0x36, 0x35, 0xc9, 0x10, 0xdf, 0x42, 0x9f, 0xc6, 0x57, 0xf0, 0xd2, 0x47, 0x90, 0xf9, 0x22, 0xb2,
	0xf4, 0xc7, 0x8a, 0x28, 0xbb, 0xf0, 0x2e, 0xdf, 0xc9, 0xc9, 0xf9, 0xce, 0x09, 0x07, 0x56, 0x8e,
	0xae, 0x6e, 0x86, 0x5e, 0x2c, 0x29, 0xb7, 0x63, 0xce, 0x24, 0xc3, 0x7a, 0x28, 0x82, 0xf6, 0xd2,
	0x81, 0x2d, 0x1f, 0x63, 0x9a, 0x40, 0xd6, 0x25, 0xd4, 0xfb, 0x09, 0xc7, 0x8d, 0x6e, 0x19, 0x6e,
	0x41, 0xf9, 0x94, 0x31, 0x39, 0x10, 0x06, 0xea, 0xa0, 0xae, 0x4e, 0xd2, 0x09, 0x1b, 0x50, 0x71,
	0x38, 0xf5, 0xee, 0x5c, 0xdf, 0xd0, 0x3a, 0xa8, 0xdb, 0x20, 0xd9, 0x88, 0xdb, 0x50, 0x4d, 0x05,
	0x84, 0xa1, 0x77, 0xf4, 0x6e, 0x83, 0xe4, 0xb3, 0xb5, 0x0e, 0xb8, 0x20, 0x4e, 0xe8, 0xfd, 0x84,
	0x0a, 0x69, 0x5d, 0xc0, 0xda, 0x37, 0x54, 0xc4, 0x2c, 0x12, 0x14, 0x6f, 0x41, 0xed, 0x98, 0x73,
	0xc6, 0xfb, 0xcc, 0xa7, 0x6a, 0x7b, 0x83, 0x7c, 0x01, 0x78, 0x17, 0x4a, 0x33, 0xb6, 0xda, 0x5e,
	0xef, 0x35, 0xed, 0x50, 0x04, 0x76, 0x51, 0x45, 0xdd, 0x5a, 0xfb, 0xd0, 0x4a, 0xc1, 0x93, 0x51,
	0x30, 0x94, 0xa3, 0x28, 0x48, 0x97, 0x62, 0x0c, 0xa5, 0x01, 0xf5, 0x42, 0x03, 0x29, 0x8b, 0xea,
	0x6c, 0xbd, 0x20, 0xd8, 0xfc, 0x41, 0x9f, 0xcb, 0x4d, 0x13, 0xf4, 0xb3, 0x51, 0xa4, 0xcc, 0x54,
	0xc9, 0xec, 0x88, 0x77, 0xa0, 0x42, 0xe8, 0x83, 0xc7, 0xfd, 0xe4, 0x17, 0xea, 0xbd, 0x9a, 0xb2,
	0xe8, 0x4a, 0x1a, 0x92, 0xec, 0x26, 0x0f, 0x51, 0xfa, 0x2b, 0x04, 0xde, 0x06, 0xcd, 0xe1, 0xc6,
	0xa2, 0xe2, 0xac, 0x2a, 0x8e, 0xe3, 0x49, 0x39, 0xa6, 0x84, 0x8a, 0xc9, 0x58, 0x12, 0xcd, 0xe1,
	0xd6, 0x1e, 0x6c, 0xa4, 0xef, 0x52, 0xe9, 0x2c, 0xe6, 0x32, 0x68, 0xae, 0x9f, 0xfa, 0xd5, 0x5c,
	0xdf, 0x7a, 0x46, 0xf9, 0x8f, 0xe4, 0xcc, 0xb9, 0x12, 0x26, 0x42, 0x5a, 0x26, 0xf4, 0x8f, 0xf9,
	0x0a, 0xad, 0x98, 0x95, 0x2b, 0x6b, 0xc5, 0x79, 0xde, 0x8a, 0x04, 0x9d, 0xcb, 0x65, 0xc1, 0x95,
	0xf6, 0x9b, 0x2b, 0xa7, 0xf9, 0x3a, 0x35, 0xd1, 0xdb, 0xd4, 0x44, 0xef, 0x53, 0x13, 0x3d, 0x7d,
	0x98, 0x0b, 0xd7, 0x65, 0xd5, 0xfd, 0xc3, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4b, 0x63, 0x43,
	0xb4, 0x21, 0x03, 0x00, 0x00,
}
